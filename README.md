# SwordTarget-OFFER
## 剑指OFFER的题目
### 按难度顺序查看：[简单](#简单)、[中等](#中等)、[较难](#较难)<br>
### 按分类查看：[数组](#数组)、[树](#树)、[字符串](#字符串)、[数学](#数学)、[链表](#链表)、[贪心](#贪心)、[排序](#排序)、[哈希](#哈希)、[位运算符](#位运算符)<br>

### 简单：<br>
1.[二叉树的深度](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.py)<br>
直接思路:递归把每个子树的高度都算出来，递归停止条件是空树，递归返回是max{左子树高度，右子树高度}+1(当前层)。运行时间23ms,占用内存5752K。<br>
参考思路:或者借助队列使用层次遍历方法，在开始时记录队列长度，然后将这个长度的个数的元素依次出队列，出队时如果此结点还有左右子树，那么将其左右子树入队。在队列长度个元素出队之后，树的高度+1。运行时间46ms,占用内存5736K<br>
2.[不用加减乘除运算符做加法](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95.py)<br>
直接思路:转换成列表型的二进制，然后用if判断来模拟手算二进制的情况，重点在于要补位。（此方法提交时内存溢出）<br>
参考思路:使用位运算符进行操作，两数异或后在左移一位取得进位。值得注意的是，此方法对于C/JAVA来说即使遇到异号数相加大于0的情况也最终会溢出并计算出正确结果，但是python是没有位数限制的，会不断无限的迭代至负无穷，所以对于此类情况应该反着来计算，并将最后结果取反。运行时间20ms，占用内存5860K<br>
3.[构建乘积数组](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.py)<br>
直接思路:使用双重循环直接实现。外层循环是传入的列表的长度，内层循环是列表中元素的乘积，遇到索引相同的则跳过这次循环。运行时间33ms，占用内存5716K<br>
参考思路:经过分析可以发现，B[i]=C[i]\*D[i],其中C[i]=A[0]\*A[1]*...*A[i-1]，D[i]=A[i+1]*...*A[n],则不难发现C[i]=C[i-1]*A\[i-1\](i=1,2...n),C[0]=1。D[i]=D[i+1]*A\[i+1\](i=0,1...n-1)，D[n]=1。有此规律，直接使用两个for循环计算出C和D数组。运行时间27ms，占用内存5816K<br>
4.[变态台阶跳](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6.py)<br>
直接思路:通过数学归纳法可以得到n台阶有的跳法为2^(n-1)。则可以直接得到结果。运行时间32 ms，占用内存5840K。<br>
参考思路:设n级台阶能够有的跳法数为f[n]，则很显然f[n]=f[n-1]+f[n-2]+...+f[0]（上一层在n-1层再跳1层+上一层在n-2层再跳2层...上一层没有再跳n层）。运行时间26ms，占用内存5860K<br>
5.[二叉树的镜像](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.py)<br>
直接思路:使用递归方法不断交换节点的左右子树。运行时间22ms,占用内存5876K。<br>
间接思路:消去递归，使用堆栈，将根节点压入栈中，然后开始循环：若栈不空，出栈一个元素，并交换其左右节点，然后再将其左右节点入栈。否则结束。运行时间21ms，占用内存5736K。<br>

### 中等：<br>
1.[重建二叉树](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.py)<br>
直接思路:先序-》第一个是根节点-》中序中寻找到这个根节点，然后将左右切分，左边的结点个数就是根节点左子树的结点个数。去先序接着根找依次这个个数的片段，找到后，又第一个是根节点，以此类推。运行时间66ms，占用内存5984K<br>
2.[剪绳子](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E5%89%AA%E7%BB%B3%E5%AD%90.py)<br>
思路：设长度为n的绳子剪成起码两段以上的绳子的乘积最大值为f(n)，则易知f(n)=max{1\*f(n-1),2\*f(n-2),...,(n-1)\*f(1)}。而且f(n)起码会切分成两段，而长度为4以下的绳子再切都不可能比原来大，所以长度4以下的绳子需要分类讨论。而大于5长度的绳子f(1)=1,f(2)=2,f(3)=3,f(4)=4。运行时间33ms,占用内存6120K<br>
3.[数据流中的中位数](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.py)<br>
直接思路:每输入一个就排序一次，那么奇数列表的中位数就是中间那个数，偶数列表的中位数就是中间两个数之和。运行时间20ms,占用内存5732K<br>
参考思路:利用最大堆和最小堆来实现，将一个数据流的有序排列看作是两个堆的存储。如\[1,2,3,4,5,6\],那么左边1,2,3存储在最大堆中，右边4,5,6存储在最小堆中。那么很显然这个列表的中位数就是最大堆的堆顶元素和最小堆的堆顶元素之和除以2。而如\[1,2,3,4,5\]，那么左边1,2,3存储在最大堆中，右边4,5存储在最小堆中，此时中位数就是最大堆的堆顶元素。那么只要每次把插入的元素，流走于两个堆之间，找到相应的位置，然后再设法将两个堆的元素个数规范，那么中位数就可容易得出。运行时间28ms,占用内存5720K<br>
4.[把二叉树打印成多行](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.py)<br>
直接思路:用队列和计数器解决，当计数器为0时，说明要开始新的一层了，将计数器置为当前队列长度，每出队一个元素，计数器减一。然后若出队结点的左右子树存在，则将其入队。不断循环这个过程，直到队列为空结束。运行时间30ms,占用内存5832k<br>
间接思路:将直接思路中的计数器用while循环代替优化。然后发现这其实是Bfs的变例。运行时间22ms，占用内存5728k<br>
5.[二叉树的下一个结点](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9.py)<br>
直接思路:首先将所给结点不断找父节点，直到找到根节点，然后对根节点使用递归中序遍历，然后将中序遍历的结果保存，然后返回定结点的下一个结点就好了。运行时间22ms,占用内存5860k<br>
6.[链表中环的入口结点](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9.py)<br>
直接思路:首先把遍历的结点保存在列表中（最好是哈希表其实，这样更快，但是我没有用哈希表）。然后判断新遍历的结点是否存在于列表中，若存在，则直接返回当前结点。否则当所有结点遍历完毕后返回None。运行时间29ms，占用内存5860k<br>
7.[字符流中第一个不重复的字符](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.py)<br>
直接思路:首先创建一个字典，用于记录字符出现的次数。再创建一个列表，用于记录插入的字符。若插入的字符在字典中不存在，则在字典中创建新的字符索引并记录值为1，否则对应索引的记录值加1。最后遍历列表，每个元素对应字典中索引中若有记录值为1的，则直接返回这个元素。若列表遍历完毕还没有返回，则返回#。运行时间21ms，占用内存5732k<br>
8.[表示数值的字符串](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.py)<br>
直接思路:没什么花里胡哨的，直接使用正则匹配，若正则匹配后的结果和原来的结果一样，则返回True，否则返回False。运行时间22ms,占用内存5720k<br>
9.[数组中重复的数字](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.py)<br>
直接思路:直接把给进的数字列表当队列，出队一个元素后判断元素是否在队列里，如果在，则表示这个元素重复，返回True，要是队列全部元素都出队了，返回False。运行时间22ms,占用内存5852k<br>
间接思路:因为给定的数组里的数字不会大于数组长度-1，所以对于没有重复元素的数组来说，必定是有0\~数组长度-1的数在数组里。所以从下标0开始，将里面的元素和这个元素下标的值进行交换，直到遇见相等的时候表示这个元素重复了。否则就一直交换，直到下标和这个下标对应的数组元素相等时，再对下一个下标重复此操作。如果最后操作完了所有下标，则返回False。运行时间21ms，占用内存5732k<br>
10.[求1+2+...+n](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E6%B1%821%2B2...%2Bn.py)<br>
直接思路:使用递归加来代替循环。利用and的短路原理来实现递归的终止。运行时间31ms,占用内存5752k<br>
11.[圆圈中最后剩下的数](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0.py)<br>
直接思路:第一次报数的时候，去掉的是下标为(m-1)%n的小朋友。第二次报数的时候，去掉的是((m-1)%n+m-1)%(n-1)下标的小朋友。所以，易得，设第n次报数去掉的小朋友下标为f\[n\]。则易知f\[1\]=(m-1)%n，f\[2\]=(f\[1\]+m-1)%(n-2)......f\[n-2\]=(f\[n-3\]+m-1)%2。所以，直接用一个列表存储0\~n-1代表n个小朋友。每k次去掉下标为f\[k\]的元素。这样，等到列表只剩1个元素的时候，那个就是剩下来的小朋友。运行时间23ms，占用内存5708k<br>
12.[扑克牌顺子](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90.py)<br>
直接思路:首先对列表进行排序，然后遍历到第一个不为0的数的下标i。将flag视为i。然后将下标为i的元素与下标i以后的元素逐个比对，如果有相同元素，直接返回false，如果下标为i的元素与后面的元素的差的绝对值大于等于0以外的数个数，那么flag的值减去超出的部分并重新赋值给flag。如果遍历结束后。flag等于0，则返回True，否则返回False。运行时间23ms,占用内存5752k<br>
改进思路:其实不用这么复杂，无论有多少个0，都必须满足最小的那个非0值减去最大的值的绝对值要小于5就可以了。所以只需要排序后，判断最大的值减最小的值的差是否小于5，若小于5则返回True，否则返回False。运行时间21ms，占用内存5624k<br>

### 较难：<br>
1.[二维数组查找](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE.py)<br>
直接思路：将二维数组每一行当做一个数组。然后分别对其进行对半搜索，搜索到则停。时间复杂度大概为O（nlogm），n为二维数组行数，m为二维数组列数。运行时间221 ms，占用内存5732K<br>
参考答案思路：由于二维数组左下角的元素是这一行的最小元素，同时也是这一列的最大元素，那么从这个位置开始对比，若目标元素大则往右走，若目标元素小则往左走。运行时间205 ms，占用内存5852K<br>
2.[替换空格](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.py)<br>
直接思路:将字符串以" "为分割点分割。然后再用"20%"组合起来。运行时间32 ms，占用内存5724K<br>
参考思路:直接使用replace方法将" "替换成"20%"。运行时间23 ms，占用内存5752K<br>
不使用函数自己写的思路:遍历一遍字符串，同时生成一个新的字符串，遍历到空格的时候生成字符串的时候生成"%20"。运行时间24ms，占用内存5860K<br>
3.[从尾到头打印链表](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.py)<br>
直接思路:和链表逆置挺像的，头插法插入列表里。如果没有insert方法的话。用堆栈放进去再弹出来。运行时间30 ms，占用内存5728K<br>
****
### 数组：<br>
1.[构建乘积数组](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.py)<br>
直接思路:使用双重循环直接实现。外层循环是传入的列表的长度，内层循环是列表中元素的乘积，遇到索引相同的则跳过这次循环。运行时间33ms，占用内存5716K<br>
参考思路:经过分析可以发现，B[i]=C[i]\*D[i],其中C[i]=A[0]\*A[1]*...*A[i-1]，D[i]=A[i+1]*...*A[n],则不难发现C[i]=C[i-1]*A\[i-1\](i=1,2...n),C[0]=1。D[i]=D[i+1]*A\[i+1\](i=0,1...n-1)，D[n]=1。有此规律，直接使用两个for循环计算出C和D数组。运行时间27ms，占用内存5816K<br>
2.[二维数组查找](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE.py)<br>
直接思路：将二维数组每一行当做一个数组。然后分别对其进行对半搜索，搜索到则停。时间复杂度大概为O（nlogm），n为二维数组行数，m为二维数组列数。运行时间221 ms，占用内存5732K<br>
参考答案思路：由于二维数组左下角的元素是这一行的最小元素，同时也是这一列的最大元素，那么从这个位置开始对比，若目标元素大则往右走，若目标元素小则往左走。运行时间205 ms，占用内存5852K<br>
3.[数组中重复的数字](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.py)<br>
直接思路:直接把给进的数字列表当队列，出队一个元素后判断元素是否在队列里，如果在，则表示这个元素重复，返回True，要是队列全部元素都出队了，返回False。运行时间22ms,占用内存5852k<br>
间接思路:因为给定的数组里的数字不会大于数组长度-1，所以对于没有重复元素的数组来说，必定是有0\~数组长度-1的数在数组里。所以从下标0开始，将里面的元素和这个元素下标的值进行交换，直到遇见相等的时候表示这个元素重复了。否则就一直交换，直到下标和这个下标对应的数组元素相等时，再对下一个下标重复此操作。如果最后操作完了所有下标，则返回False。运行时间21ms，占用内存5732k<br>
4.[圆圈中最后剩下的数](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0.py)<br>
直接思路:第一次报数的时候，去掉的是下标为(m-1)%n的小朋友。第二次报数的时候，去掉的是((m-1)%n+m-1)%(n-1)下标的小朋友。所以，易得，设第n次报数去掉的小朋友下标为f\[n\]。则易知f\[1\]=(m-1)%n，f\[2\]=(f\[1\]+m-1)%(n-2)......f\[n-2\]=(f\[n-3\]+m-1)%2。所以，直接用一个列表存储0\~n-1代表n个小朋友。每k次去掉下标为f\[k\]的元素。这样，等到列表只剩1个元素的时候，那个就是剩下来的小朋友。运行时间23ms，占用内存5708k<br>

### 树：<br>
1.[二叉树的深度](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.py)<br>
直接思路:递归把每个子树的高度都算出来，递归停止条件是空树，递归返回是max{左子树高度，右子树高度}+1(当前层)。运行时间23ms,占用内存5752K。<br>
参考思路:或者借助队列使用层次遍历方法，在开始时记录队列长度，然后将这个长度的个数的元素依次出队列，出队时如果此结点还有左右子树，那么将其左右子树入队。在队列长度个元素出队之后，树的高度+1。运行时间46ms,占用内存5736K<br>
2.[二叉树的镜像](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.py)<br>
直接思路:使用递归方法不断交换节点的左右子树。运行时间22ms,占用内存5876K。<br>
间接思路:消去递归，使用堆栈，将根节点压入栈中，然后开始循环：若栈不空，出栈一个元素，并交换其左右节点，然后再将其左右节点入栈。否则结束。运行时间21ms，占用内存5736K。<br>
3.[重建二叉树](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.py)<br>
直接思路:先序-》第一个是根节点-》中序中寻找到这个根节点，然后将左右切分，左边的结点个数就是根节点左子树的结点个数。去先序接着根找依次这个个数的片段，找到后，又第一个是根节点，以此类推。运行时间66ms，占用内存5984K<br>
4.[把二叉树打印成多行](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.py)<br>
直接思路:用队列和计数器解决，当计数器为0时，说明要开始新的一层了，将计数器置为当前队列长度，每出队一个元素，计数器减一。然后若出队结点的左右子树存在，则将其入队。不断循环这个过程，直到队列为空结束。运行时间30ms,占用内存5832k<br>
间接思路:将直接思路中的计数器用while循环代替优化。然后发现这其实是Bfs的变例。运行时间22ms，占用内存5728k<br>
5.[二叉树的下一个结点](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9.py)<br>
直接思路:首先将所给结点不断找父节点，直到找到根节点，然后对根节点使用递归中序遍历，然后将中序遍历的结果保存，然后返回定结点的下一个结点就好了。

### 字符串：<br>
1.[替换空格](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.py)<br>
直接思路:将字符串以" "为分割点分割。然后再用"20%"组合起来。运行时间32 ms，占用内存5724K<br>
参考思路:直接使用replace方法将" "替换成"20%"。运行时间23 ms，占用内存5752K<br>
不使用函数自己写的思路:遍历一遍字符串，同时生成一个新的字符串，遍历到空格的时候生成字符串的时候生成"%20"。运行时间24ms，占用内存5860K<br>
2.[表示数值的字符串](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.py)<br>
直接思路:没什么花里胡哨的，直接使用正则匹配，若正则匹配后的结果和原来的结果一样，则返回True，否则返回False。运行时间22ms,占用内存5720k<br>

### 数学：<br>
1.[变态台阶跳](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6.py)<br>
直接思路:通过数学归纳法可以得到n台阶有的跳法为2^(n-1)。则可以直接得到结果。运行时间32 ms，占用内存5840K。<br>
参考思路:设n级台阶能够有的跳法数为f[n]，则很显然f[n]=f[n-1]+f[n-2]+...+f[0]（上一层在n-1层再跳1层+上一层在n-2层再跳2层...上一层没有再跳n层）。运行时间26ms，占用内存5860K<br>
2.[不用加减乘除运算符做加法](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95.py)<br>
直接思路:转换成列表型的二进制，然后用if判断来模拟手算二进制的情况，重点在于要补位。（此方法提交时内存溢出）<br>
参考思路:使用位运算符进行操作，两数异或后在左移一位取得进位。值得注意的是，此方法对于C/JAVA来说即使遇到异号数相加大于0的情况也最终会溢出并计算出正确结果，但是python是没有位数限制的，会不断无限的迭代至负无穷，所以对于此类情况应该反着来计算，并将最后结果取反。运行时间20ms，占用内存5860K<br>
3.[扑克牌顺子](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90.py)<br>
直接思路:首先对列表进行排序，然后遍历到第一个不为0的数的下标i。将flag视为i。然后将下标为i的元素与下标i以后的元素逐个比对，如果有相同元素，直接返回false，如果下标为i的元素与后面的元素的差的绝对值大于等于0以外的数个数，那么flag的值减去超出的部分并重新赋值给flag。如果遍历结束后。flag等于0，则返回True，否则返回False。运行时间23ms,占用内存5752k<br>
改进思路:其实不用这么复杂，无论有多少个0，都必须满足最小的那个非0值减去最大的值的绝对值要小于5就可以了。所以只需要排序后，判断最大的值减最小的值的差是否小于5，若小于5则返回True，否则返回False。运行时间21ms，占用内存5624k<br>

### 链表：<br>
1.[从尾到头打印链表](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.py)<br>
直接思路:和链表逆置挺像的，头插法插入列表里。如果没有insert方法的话。用堆栈放进去再弹出来。运行时间30 ms，占用内存5728K<br>
2.[链表中环的入口结点](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9.py)<br>
直接思路:首先把遍历的结点保存在列表中（最好是哈希表其实，这样更快，但是我没有用哈希表）。然后判断新遍历的结点是否存在于列表中，若存在，则直接返回当前结点。否则当所有结点遍历完毕后返回None。运行时间29ms,占用内存5860k<br>

### 贪心：<br>
1.[剪绳子](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E5%89%AA%E7%BB%B3%E5%AD%90.py)<br>
思路：设长度为n的绳子剪成起码两段以上的绳子的乘积最大值为f(n)，则易知f(n)=max{1\*f(n-1),2\*f(n-2),...,(n-1)\*f(1)}。而且f(n)起码会切分成两段，而长度为4以下的绳子再切都不可能比原来大，所以长度4以下的绳子需要分类讨论。而大于5长度的绳子f(1)=1,f(2)=2,f(3)=3,f(4)=4。运行时间33ms,占用内存6120K<br>

### 排序：<br>
1.[数据流中的中位数](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.py)<br>
直接思路:每输入一个就排序一次，那么奇数列表的中位数就是中间那个数，偶数列表的中位数就是中间两个数之和。运行时间20ms,占用内存5732K<br>
参考思路:利用最大堆和最小堆来实现，将一个数据流的有序排列看作是两个堆的存储。如\[1,2,3,4,5,6\],那么左边1,2,3存储在最大堆中，右边4,5,6存储在最小堆中。那么很显然这个列表的中位数就是最大堆的堆顶元素和最小堆的堆顶元素之和除以2。而如\[1,2,3,4,5\]，那么左边1,2,3存储在最大堆中，右边4,5存储在最小堆中，此时中位数就是最大堆的堆顶元素。那么只要每次把插入的元素，流走于两个堆之间，找到相应的位置，然后再设法将两个堆的元素个数规范，那么中位数就可容易得出。运行时间28ms,占用内存5720K<br>

### 哈希：<br>
1.[字符流中第一个不重复的字符](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.py)<br>
直接思路:首先创建一个字典，用于记录字符出现的次数。再创建一个列表，用于记录插入的字符。若插入的字符在字典中不存在，则在字典中创建新的字符索引并记录值为1，否则对应索引的记录值加1。最后遍历列表，每个元素对应字典中索引中若有记录值为1的，则直接返回这个元素。若列表遍历完毕还没有返回，则返回#。运行时间21ms，占用内存5732k<br>

### 位运算符：<br>
1.[求1+2+...+n](https://github.com/IPostYellow/SwordTarget-OFFER/blob/master/%E6%B1%821%2B2...%2Bn.py)<br>
直接思路:使用递归加来代替循环。利用and的短路原理来实现递归的终止。运行时间31ms,占用内存5752k<br>
